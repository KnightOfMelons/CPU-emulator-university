# Инструкция для CPU
code = [
    "push 2",  # Помещаем 2 на стек
    "push 3",  # Помещаем 3 на стек
    "add",  # Складываем верхние два элемента на стеке
    "push 5",  # Помещаем 5 на стек
    "add",  # Складываем результат с 5
]

# Память (фон-неймановская архитектура)
memory = []

# Стек
stack = []

# EIP - Указатель на текущую инструкцию
EIP = 0

# Выполняем команды
while EIP < len(code):
    instruction = code[EIP]

    # Разбиваем инструкцию на команду и операнды (если есть)
    parts = instruction.split()
    mnemonic = parts[0]

    # Эмуляция инструкции
    if mnemonic == "push":
        # PUSH <imm> - помещаем значение в стек
        value = int(parts[1])
        stack.append(value)

    elif mnemonic == "add":
        # ADD - складываем два верхних элемента стека
        if len(stack) < 2:
            print("Ошибка: недостаточно элементов в стеке для выполнения операции 'add'")
            break
        b = stack.pop()  # Снимаем верхний элемент
        a = stack.pop()  # Снимаем следующий элемент
        result = a + b  # Складываем
        stack.append(result)  # Помещаем результат обратно на стек

    else:
        print(f"Инструкция '{mnemonic}' не поддерживается")
        break

    # Увеличиваем указатель на инструкцию
    EIP += 1

# Выводим результат
if stack:
    print(f"Результат вычислений: {stack[-1]}")
else:
    print("Стек пуст после выполнения инструкций.")
